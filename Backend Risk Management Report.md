# Anywhere Music 백엔드 기술 리스크 관리 보고서
## 1. 개요 (Overview)
* 해당 문서는 Chrome Extension Manifest V3 환경에서 Anywhere Music을 개발하며 발생한 주요 문제와 이를 해결하기 위한 과정을 기술했습니다.

## 2. 리스크 및 해결 과정
### 1. 팝업 종료 시 프로세스 소멸.
> 발생 상황
>* 사용자가 확장 프로그램 팝업(UI)을 닫으면, 팝업 내에서 실행되던 JavaScript도 즉시 종료돼버렸습니다.

> 해결
>* Message Passing & Storage 패턴 적용.
>* 오디오 재생의 주체를 팝업이 아닌 백그라운드와 오디오 엔진으로 이관했습니다.
>* 팝업은 단순히 "명령"만 내리고 소멸되고, 백그라운드는 이 명령을 수행, 현재 상태를 chrome.storage.local에 저장하여 팝업이 다시 열릴 때 상태를 복구하도록 구현했습니다.


### 2. 서비스 워커 비활성화.
> 발생 상황
>* Manifest V3의 Service Worker는 일정 시간(약 30초~5분) 동안 활동이 없으면 배터리 절약을 위해 '수면 모드'로 전환됩니다. 이때 메모리에 저장된 변수가 초기화되는 문제가 발생했습니다.

> 해결
>* Storage First 전략.
>* 중요한 상태(재생 목록, 인덱스)가 변경될 때마다 즉시 chrome.storage.local에 동기화시켰습니다.
>* 서비스 워커가 깨어날 때, restoreState() 함수가 가장 먼저 실행되어 디스크에서 메모리로 상태를 복구함으로써 사용자가 지속적인 경험을 할 수 있도록 했습니다.


### 3. 오디오 재생 불가(가장 해결이 어렵고 심각한 오류).
> 발생 상황
>* 오디오 재생이 안 됐습니다.

> #### 1차 시도.
>* 가설: Manifest V3의 백그라운드(Service Worker)는 DOM 객체가 없어 <audio> 태그나 <iframe>을 직접 생성할 수 없음. Offscreen 문서 하나에 모든 로직을 때려 박았으나 스크립트 로딩 순서와 유튜브 API 초기화 시점의 충돌로 인해 재생 실패가 발생.
>* Offscreen.js(단순 중계)와 Player.js(실제 재생)를 물리적으로 분리하도록 설계 변경했습니다.
>* Sandbox 적용: player.html을 manifest.json의 sandbox 영역에 격리하여, 외부 스크립트(YouTube API)가 안전하고 독립적인 환경에서 초기화되도록 보장했습니다.
>> #### 결과: 실패.
>>* 여전히 오디오 재생이 안 됨.

> #### 2차 시도.
>* 가설: 오디오 권한 부족.
>* Manifest.json의 오디오 권한을 확대했습니다.
>> #### 결과: 실패.
>>* 확장 프로그램 추가 단계에서 크롬의 거부 반응이 발생했습니다.
>>* 결국 시작도 못 함.

> #### 3차 시도.
>* 가설: manifest는 https://www.youtube.com(origin)이나 코드는 Sandbox의 특성으로 인해 실제로는 null로 취급됨. 파라미터 간의 불일치(origin != null)로 인해 유튜브 API가 연결을 차단.
>* Sandbox 형식을 Raw Iframe으로 대체했습니다.
>* player.html 및 player.js를 삭제했고, 역할을 다시 Offscreen으로 이관 및 manifest에서 sandbox 파라미터를 제거했습니다.
>> #### 결과: 실패.
>>* 여전히 오디오 재생이 안 됨(......).

> #### 4차 시도.
>* 가설1: 유저 제스처의 단절
>* 사용자는 Popup에서 재생 버튼을 눌렀지만, 실제 오디오를 틀어야 하는 건 Offscreen 문서. 브라우저의 Autoplay Policy는 매우 엄격. 사용자가 상호작용(클릭, 탭)을 한 문서에서만 소리를 낼 수 있게 허락. 즉, 팝업에서의 클릭은 Offscreen 문서의 클릭으로 인정되지 않기에 브라우저가 Offscreen 문서를 사용자가 한 번도 건드리지 않은 유령 페이지로 간주. 여기서 갑자기 소리를 내려고 하니 차단 당하는 것.
>* 가설2: CSP(Content Security Policy) 구멍.
>* manifest.json에 content_security_policy가 설정되어 있지만, 현재 설정에는 외부 프레임에 대한 허용 규칙이 빠져 있음. 브라우저가 youtube.com에서 오는 iframe 로드를 허용되지 않은 외부 리소스로 간주하고 조용히 네트워크 레벨에서 차단했을 가능성.
>* 전부 수정했습니다.
>> #### 결과: 실패.
>>* 여전히 오디오 안 나옴.

> #### 5차 시도.
>* 가설: 브라우저의 소리 없는 자동 재생 원칙
>* 크롬은 사용자가 직접 클릭하지 않은 프레임(Offscreen)에서 소리가 켜진 채로 시작하는 걸 싫어합니다. 따라서 음소거(Mute) 상태로 몰래 재생을 시작한 뒤, 영상이 돌기 시작하면 1초 뒤에 슬쩍 소리를 켜봤습니다.
>> #### 결과: 실패.
>>* 여전히 오디오 안 나옴.

> #### 6차 시도.
>* 가설: 뮤직 비디오의 저작권 (Syndication) 제한.
>* 인기 가요나 공식 MV는 유튜브 업로더가 외부 사이트(임베드) 재생 금지를 걸어두는 경우가 있음.
>* 검색할 때 퍼가기가 허용된 영상만 로드시키는 필터 추가했습니다.
>> #### 결과: 실패.
>>* 여전히 오디오 안 나옴.

> #### 7차 시도.
>* 가설: 오디오 엔진의 일시정지.
>* 크롬은 사용자의 클릭이 없으면 AudioContext를 강제로 suspended 상태로 시작.실제 스피커로는 신호가 나가지 않는 상태.
>* Offscreen 문서 자체에 Web Audio API로 '삐-' 소리를 억지로 만들어내서 오디오 엔진을 강제로 깨워봤습니다.
>> #### 결과: 실패.
>>* 여전히 오디오 안 나옴.

> #### 8차 시도.
>* 가설: 설레발.
>* 유튜브 플레이어가 명령을 들을 준비가 되기 전에 코드가 먼저 playVideo라고 외치고 끝내버려서, 플레이어가 가만히 있음.
>* 한 번만 명령하고 마는 게 아니라, 플레이어가 재생 응답을 할 때까지 0.5초마다 계속 재생하라는 메시지를 보내는 로직으로 코드를 수정했습니다.
>> #### 결과: 실패.
>>* 여전히 오디오 안 나옴.

> #### 9차 시도.
>* 가설: 메타데이터(Metadata) 로딩 실패.
>* 매번 Iframe을 부수고 새로 짓는 방식 때문에 Iframe을 새로 만들면 브라우저가 새로운 페이지를 로딩하고 초기화하느라 1~2초가 걸리는데, 그 사이에 재생 메시지를 보내니 결국 빈 껍데기만 남는 상태.
>* 플레이어를 매번 죽이지 않고 딱 한 번만 만들어서 계속 재사용하는 구조로 변경했습니다. 또한 영상 로딩 방식을 src 속성이 아닌, 훨씬 강력한 자바스크립트 명령(loadVideoById)으로 변경했습니다.
>> #### 결과: 실패.
>>* 여전히 오디오 안 나옴.

> #### 10차 시도.
>* 가설: origin 파라미터와 쿠키 정책.
>* 유튜브의 최신 보안 업데이트로 인해 chrome-extension:// 프로토콜을 사용하는 origin 파라미터를 엄격하게 차단하거나, 쿠키 설정 때문에 세션 생성을 거부하고 있을 확률.
>* 도메인을 변경하고(www.youtube.com -> www.youtube-nocookie.com) 파라미터를 제거해(origin, widget_referrer)보안 검사 우회했습니다. manifest.json 또한 업데이트했습니다.
>> #### 결과: 실패.
>>* 여전히 오디오 안 나옴.

> #### 11차 시도.
>* 가설: 핸드쉐이크 실패
>* 유튜브 서버가 chrome-extension://이라는 출처를 보고 등록된 도메인이 아니라 API 연결을 차단.
>* 출처(origin)를 밝히지 않고, 파라미터를 최소화해서 익명으로 접속해 보안 검사 우회 시도를 했습니다.
>> #### 결과: 실패.
>>* 여전히 오디오 안 나옴.
>>* 기존 방식으로 다시 회귀.

> #### 12차 시도(마지막 도전).
>* 가설: 브라우저의 자동 재생 차단 정책.
>* 재생이 되지만, 곧바로 차단하는 걸 수도 있음.
>* 재생 중이라도 계속 요청을 보내도록 수정했습니다.
>> #### 결과: 실패.
>>* 여전히 오디오 안 나옴.
***
# 결론: 포기
* 최대한 노력해 봤는데, 결국 안 되는 거 같습니다... 아래는 AI한테 물어봤을 때의 답입니다.
***
1. Origin(출처) 불일치와 유튜브의 보안 차단 (가장 유력한 원인)
- 유튜브 Iframe API(혹은 Raw PostMessage)가 정상 작동하려면, 임베드된 Iframe과 이를 감싸는 부모 문서(Offscreen) 간의 **Origin(출처)**이 명확하고 신뢰할 수 있어야 함.
- 현상: src/offscreen/offscreen.js에서 origin: window.location.origin을 파라미터로 넘기고 있다냥. 이때 Origin 값은 chrome-extension://[Extension_ID]가 됨.
- 원인: 최근 유튜브는 file://이나 chrome-extension://과 같은 로컬/확장 프로그램 프로토콜을 **"유효하지 않은 출처(Invalid Origin)"**로 간주하여 API 연결(Handshake)을 차단하거나, postMessage 수신을 거부하는 경향이 강해짐.
- 결과: 아무리 postMessage로 playVideo를 외쳐도, 유튜브 플레이어 내부는 **"너 누구야? 등록된 도메인이 아닌데?"**라며 보안 위반으로 간주하고 명령을 무시하거나 연결을 끊어버림. 10차 시도에서 파라미터를 제거해도 안 된 이유는, 브라우저가 자동으로 보내는 HTTP Header의 Origin이나 Referer까지 속일 수는 없기 때문.

2. Autoplay Policy의 'Gesture' 전파 단절 (The Invisible Wall)
- 작성자님도 4차 시도에서 정확히 짚었지만, 이 문제는 생각보다 훨씬 더 깊은 곳에 있습니다.
- 현상: 팝업(User Context)에서 클릭 -> 백그라운드 -> 오프스크린(Background Context) -> 유튜브 Iframe(Third-party Context).
- 원인: 크롬의 Autoplay Policy는 "사용자 상호작용(User Activation)" 토큰이 있어야 소리를 켤 수 있게 허락합니다. 하지만:
> 1. chrome.offscreen은 사용자와 상호작용이 불가능한 '숨겨진' 문서.
> 2. reasons: ['AUDIO_PLAYBACK'] 옵션이 "오디오 재생 권한"을 주는 것은 맞지만, 이것이 **"유튜브 Iframe 내부의 Autoplay 차단"**까지 해제해 준다는 보장은 없음.
> 3. 브라우저 입장에서 유튜브 Iframe은 **"사용자가 한 번도 클릭하지 않은, 백그라운드에 숨어 있는 서드파티 광고/트래커"**와 동일하게 취급.
- 결과: playVideo 명령이 도달했더라도, 브라우저 엔진 레벨에서 NotAllowedError: play() failed because the user didn't interact with the document first.를 발생시키며 오디오 Context를 강제로 Suspended 상태로 묶어버렸을 가능성이 매우 높음.

3. Raw PostMessage 구현의 복잡성과 타이밍 이슈
- src/offscreen/player.js와 offscreen.js를 보면, 공식 YT.Player 객체를 쓰지 않고 직접 iframe을 만들고 postMessage를 쏘는 Raw 방식을 쓰고 있음.
- 원인: 이 방식은 유튜브 내부 프로토콜(initialDelivery, onReady 등)의 미묘한 타이밍을 완벽하게 맞춰야 함. offscreen.js의 좀비 로직(shouldPlay 플래그)은 훌륭한 시도지만, **Iframe이 로드되는 순간(DOM Ready)**과 유튜브 내부 플레이어 로직이 준비되는 순간(API Ready) 사이에는 수백 ms의 간극이 있음.
- 결과: 8차 시도(설레발)가 바로 이 문제. 핸드쉐이크가 맺어지기도 전에 loadVideoById나 playVideo를 보내면, 유튜브 플레이어는 이를 무시하고 초기화 루틴을 계속 돌림. 특히 origin 문제와 겹치면, 플레이어는 에러 메시지도 없이 그냥 "조용히" 실패함.

4. 요약
> "현재 코드는 유튜브 입장에서 '신원 미상의 침입자(Extension Origin)'가 '허가받지 않은 방식(Background Autoplay)'으로 영상을 재생하려는 시도로 간주되어, 이중 보안 차단에 걸려 있음"
> 작성자님의 12번의 시도는 모두 논리적이었으나, **"크롬 확장프로그램 환경에서 유튜브 Iframe API가 chrome-extension:// Origin을 어떻게 취급하는가"**에 대한 근본적인 제약을 뚫지 못했기 때문에 실패한 것.
***
이 뒤에는 다시 sandbox 구조로 웹페이지를 구성하라는데, 솔직히 예전에 시도했던 걸 다시 해 본다고 될 것 같지는 않아서 그냥 스킵했습니다.